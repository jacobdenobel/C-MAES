#pragma once

#include <memory>
#include <random>
#include <vector>
#include <utility>

#include <Eigen/Eigen>

namespace sampling
{

    static inline int SEED = 0;
    static inline std::mt19937 GENERATOR(SEED);

    /**
     * @brief Set the global seed and reseed the random generator (mt19937)
     *
     * @param seed
     */
    void set_seed(const int seed)
    {
        SEED = seed;
        GENERATOR.seed(seed);
    }

    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        virtual Eigen::VectorXd operator()() = 0;
        size_t d;
    };

    /**
     * @brief Testing every row a new number
     *
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        Eigen::VectorXd operator()() override
        {
            Eigen::VectorXd x(d);
            ++i;
            x.array() = static_cast<double>(i);
            return x;
        };

    private:
        size_t i = 0;
    };

    /**
     * @brief Gaussian sampling functor
     *
     */
    struct Gaussian : Sampler
    {

        Gaussian(const size_t d) : Sampler(d) {}

        [[nodiscard]] Eigen::VectorXd operator()() override
        {
            Eigen::VectorXd x(d);
            for (auto &xi : x)
                xi = dist(GENERATOR);
            return x;
        }

    private:
        std::normal_distribution<> dist = {};
    };

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> &sampler) : Sampler(sampler->d), sampler(sampler) {}

        Eigen::VectorXd operator()() override
        {
            if (!mirror)
            {
                previous = (*sampler)();
                mirror = true;
                return previous;
            }
            mirror = false;
            return -previous;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Eigen::VectorXd previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(d, n), samples(d, n), I(Eigen::MatrixXd::Identity(n, n))
        {
        }

        Eigen::VectorXd operator()() override
        {
            if (current >= n)
                current = 0;

            if (!current)
            {
                for (size_t i = 0; i < n; ++i)
                    samples.col(i) = (*sampler)();

                auto norm = samples.colwise().norm().asDiagonal();

                // Jacob: this is what we do in python, but this might be wrong
                // qr.compute(samples.transpose());
                // samples = ((qr.householderQ() * I).transpose() * norm).transpose();

                // Jacob: this seems correct;
                qr.compute(samples);
                samples = qr.householderQ() * I * norm;
            }
            return samples.col(current++);
        }

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Eigen::MatrixXd samples;
        Eigen::HouseholderQR<Eigen::MatrixXd> qr;
        Eigen::MatrixXd I;
        size_t current = 0;
    };

    struct Halton : Sampler
    {
        Halton(const size_t d, const size_t i = 1) : Sampler(d), i(i)
        {
            primes = sieve(std::max(6, static_cast<int>(d)));
            while(primes.size() < d)
                primes = sieve(primes.size() * primes.size());
            primes.resize(d);
        }
        
        Eigen::VectorXd operator()() override
        {
            Eigen::VectorXd res(d);
            for (size_t j = 0; j < d; ++j) 
                res(j) = next(i, primes[j]);
            i++;
            return res;           
        }


        static double next(int index, int base) {
            double y = 1., x = 0.;
            while (index > 0){
                auto dm = divmod(index, base);
                index = dm.first;
                y *= static_cast<double>(base);
                x += static_cast<double>(dm.second) / y;
            }
            return x;
        }

        

    private:
        size_t i;
    public:
        std::vector<int> primes;
        
        static std::pair<int, int> divmod(const double top, const double bottom){
            const auto div = static_cast<int>(top / bottom);
            return {div, top - div * bottom};
        }
        
        static std::vector<int> sieve(const int n)
        {
            // Jacob: not the correct result, prime 29 not found
            std::vector<unsigned char> mask(n / 3 + (n % 6 == 2), 1);
            size_t s = static_cast<size_t>(pow(n, .5)) / 3 + 1;
            for (size_t i = 1; i < s; ++i)
            {
                if (mask[i])
                {
                    auto k = 3 * i + 1 | 1;
                    for (int j = k * k / 3; j < 2 * k; ++j)
                        mask[j] = 0;
                    for (int j = k * (k - 2 * (i & 1) + 4) / 3; j < 2 * k; ++j)
                        mask[j] = 0;
                }
            }

            std::vector<int> primes = {2, 3};
            for (size_t i = 1; i < mask.size(); ++i)
                if (mask[i])
                    primes.push_back((3 * i + 1) | 1);

            return primes;
        }
    };

    struct Sobol : Sampler
    {
    };
}

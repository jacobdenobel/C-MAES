#pragma once

#include "common.hpp"

//! see ndtri.cpp
double ppf(const double x);

//! sobol.cpp
void i8_sobol(int dim_num, long long int *seed, double quasi[]);

namespace sampling
{

    /**
     * @brief Sampler generic class, functor return a vector of random
     * numbers for a given size.
     */
    struct Sampler
    {
        Sampler(const size_t d) : d(d) {}
        [[nodiscard]] virtual Vector operator()() = 0;
        size_t d;
    };

    /**
     * @brief Testing sampler, simple incrementing generator.
     *
     */
    struct Tester : Sampler
    {
        Tester(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            ++i;
            x.array() = static_cast<double>(i);
            return x;
        };

    private:
        size_t i = 0;
    };

    /**
     * @brief Gaussian sampling functor
     *
     */
    struct Gaussian : Sampler
    {

        Gaussian(const size_t d) : Sampler(d) {}

        [[nodiscard]] Vector operator()() override
        {
            Vector x(d);
            for (auto &xi : x)
                xi = dist(rng::GENERATOR);
            return x;
        }

    private:
        std::normal_distribution<> dist = {};
    };

    /**
     * @brief Mirrored sampler, returns the original sample generated by
     * the provided sampler, followed by its reversed form.
     *
     */
    struct Mirrored : Sampler
    {
        Mirrored(const std::shared_ptr<Sampler> &sampler) : Sampler(sampler->d), sampler(sampler) {}

        [[nodiscard]] Vector operator()() override
        {
            if (!mirror)
            {
                previous = (*sampler)();
                mirror = true;
                return previous;
            }
            mirror = false;
            return -previous;
        }

    private:
        std::shared_ptr<Sampler> sampler;
        Vector previous;
        bool mirror = false;
    };

    /**
     * @brief Orthogonal sampler.    
     * This function orthogonalizes <n_samples>, and succesively yields each
     * of them. It uses HouseHolderQR decomposition in order to compute 
     * the orthonomalization.
     * 
     * Note: result for this thing is not precisly the same as python version
     *
     */
    struct Orthogonal : Sampler
    {
        Orthogonal(const std::shared_ptr<Sampler> sampler, const size_t n_samples)
            : Sampler(sampler->d), sampler(sampler), n(std::max(d, n_samples)),
              qr(n, d), samples(d, n), I(Matrix::Identity(n, d))
        {
        }

        [[nodiscard]] Vector operator()() override
        {
            if (current >= n)
                current = 0;

            if (!current)
            {
                for (size_t i = 0; i < n; ++i)
                    samples.col(i) = (*sampler)();

                auto norm = samples.colwise().norm().asDiagonal();

                qr.compute(samples.transpose());
                samples = ((qr.householderQ() * I).transpose() * norm);
            }
            return samples.col(current++);
        }

    private:
        std::shared_ptr<Sampler> sampler;
        size_t n;
        Matrix samples;
        Eigen::HouseholderQR<Matrix> qr;
        Matrix I;
        size_t current = 0;
    };

    
    /**
     * @brief Generator yielding samples from a Halton sequence.
     * 
     */
    struct Halton : Sampler
    {
        Halton(const size_t d, const size_t i = 1) : Sampler(d), i(i)
        {
            primes = sieve(std::max(6, static_cast<int>(d)));
            while (primes.size() < d)
                primes = sieve(primes.size() * primes.size());
            primes.resize(d);
        }

        [[nodiscard]] Vector operator()() override
        {
            Vector res(d);
            for (size_t j = 0; j < d; ++j)
                res(j) = ppf(next(i, primes[j]));
            i++;
            return res;
        }

        size_t i;
        std::vector<int> primes;

    private:
        static double next(int index, int base)
        {
            double y = 1., x = 0.;
            while (index > 0)
            {
                auto dm = divmod(index, base);
                index = dm.first;
                y *= static_cast<double>(base);
                x += static_cast<double>(dm.second) / y;
            }
            return x;
        }

        static std::pair<int, int> divmod(const double top, const double bottom)
        {
            const auto div = static_cast<int>(top / bottom);
            return {div, top - div * bottom};
        }

        static std::vector<int> sieve(const int n)
        {
            std::vector<unsigned char> mask(n / 3 + (n % 6 == 2), 1);
            size_t s = static_cast<size_t>(pow(n, .5)) / 3 + 1;
            for (size_t i = 1; i < s; ++i)
            {
                if (mask[i])
                {
                    auto k = 3 * i + 1 | 1;
                    for (int j = k * k / 3; j < 2 * k - 1; ++j)
                        mask[j] = 0;
                    for (int j = k * (k - 2 * (i & 1) + 4) / 3; j < 2 * k - 1; ++j)
                        mask[j] = 0;
                }
            }

            std::vector<int> primes = {2, 3};
            for (size_t i = 1; i < mask.size(); ++i)
                if (mask[i])
                    primes.push_back((3 * i + 1) | 1);

            return primes;
        }
    };

    /**
     * @brief Generator yielding samples from a Sobol sequence.
     * 
     */
    struct Sobol : Sampler
    {
        Sobol(const size_t d) : Sampler(d), seed(rng::random_integer(2, std::max(3, static_cast<int>(d * d))))
        {
        }

        [[nodiscard]] Vector operator()() override
        {
            Vector res(d);
            i8_sobol(d, &seed, res.data());
            for (size_t j = 0; j < d; ++j)
                res(j) = ppf(res(j));

            seed += d;
            return res;
        }

    private:
        long long seed;
    };
}
